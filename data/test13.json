{
  "summary": {
    "total": 50,
    "correct": 25,
    "wrong": 25,
    "error": 0,
    "accuracy": 50.0
  },
  "correct_problems": [
    "FOLIO_dev_43",
    "FOLIO_dev_59",
    "FOLIO_dev_0",
    "FOLIO_dev_144",
    "FOLIO_dev_83",
    "FOLIO_dev_13",
    "FOLIO_dev_111",
    "FOLIO_dev_89",
    "FOLIO_dev_126",
    "FOLIO_dev_134",
    "FOLIO_dev_60",
    "FOLIO_dev_48",
    "FOLIO_dev_66",
    "FOLIO_dev_44",
    "FOLIO_dev_178",
    "FOLIO_dev_85",
    "FOLIO_dev_73",
    "FOLIO_dev_196",
    "FOLIO_dev_26",
    "FOLIO_dev_77",
    "FOLIO_dev_129",
    "FOLIO_dev_40",
    "FOLIO_dev_176",
    "FOLIO_dev_53",
    "FOLIO_dev_21"
  ],
  "wrong_problems": [
    "FOLIO_dev_125",
    "FOLIO_dev_17",
    "FOLIO_dev_107",
    "FOLIO_dev_130",
    "FOLIO_dev_51",
    "FOLIO_dev_25",
    "FOLIO_dev_101",
    "FOLIO_dev_49",
    "FOLIO_dev_172",
    "FOLIO_dev_8",
    "FOLIO_dev_22",
    "FOLIO_dev_200",
    "FOLIO_dev_33",
    "FOLIO_dev_152",
    "FOLIO_dev_76",
    "FOLIO_dev_23",
    "FOLIO_dev_11",
    "FOLIO_dev_150",
    "FOLIO_dev_170",
    "FOLIO_dev_31",
    "FOLIO_dev_14",
    "FOLIO_dev_4",
    "FOLIO_dev_132",
    "FOLIO_dev_171",
    "FOLIO_dev_169"
  ],
  "details": [
    {
      "id": "FOLIO_dev_43",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nplayer = Bool(\"player\")\nranked_highly = Bool(\"ranked_highly\")\nmost_active = Bool(\"most_active\")\nlost_to_iga = Bool(\"lost_to_iga\")\nfemale_roland_garros = Bool(\"female_roland_garros\")\nmale_roland_garros = Bool(\"male_roland_garros\")\nlost_to_rafael = Bool(\"lost_to_rafael\")\ncoco_gauff = Bool(\"coco_gauff\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis\nsolver.add(Implies(ranked_highly, most_active))\n\n# Rule 2: Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association\nsolver.add(Implies(lost_to_iga, ranked_highly))\n\n# Rule 3: All female tennis players at Roland Garros 2022 lost to Iga Świątek\nsolver.add(Implies(female_roland_garros, lost_to_iga))\n\n# Rule 4: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022\nsolver.add(Or(female_roland_garros, male_roland_garros))\n\n# Rule 5: All male tennis players at Roland Garros 2022 lost to Rafael Nadal\nsolver.add(Implies(male_roland_garros, lost_to_rafael))\n\n# Rule 6: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022\nsolver.add(Implies(Or(ranked_highly, lost_to_rafael), Not(male_roland_garros)))\n\n# Create assertions to check the query\nsolver.add(coco_gauff == lost_to_rafael)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(coco_gauff))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(coco_gauff)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Coco Gauff has lost to Rafael Nadal\nelse:\n    print(\"B\")  # False - Coco Gauff has not lost to Rafael Nadal",
      "context": "If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association. All female tennis players at Roland Garros 2022 lost to Iga Świątek. Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. All male tennis players at Roland Garros 2022 lost to Rafael Nadal. If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Coco Gauff has lost to Rafael Nadal.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_59",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nbillings_is_city = Bool(\"billings_is_city\")\nmontana_includes_butte = Bool(\"montana_includes_butte\")\nmontana_includes_helena = Bool(\"montana_includes_helena\")\nmontana_includes_missoula = Bool(\"montana_includes_missoula\")\nwhite_sulphur_springs_is_city = Bool(\"white_sulphur_springs_is_city\")\nbutte_is_city = Bool(\"butte_is_city\")\npierre_is_city = Bool(\"pierre_is_city\")\nbutte_not_in_pierre = Bool(\"butte_not_in_pierre\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Billings is a city in Montana\nsolver.add(Implies(billings_is_city, montana_includes_butte))\n# Rule 2: Montana includes the cities of Butte, Helena, and Missoula\nsolver.add(And(montana_includes_butte, montana_includes_helena, montana_includes_missoula))\n# Rule 3: White Sulphur Springs and Butte are cities in the same state\nsolver.add(And(white_sulphur_springs_is_city, butte_is_city))\n# Rule 4: The city of Pierre is not in Montana\nsolver.add(Not(pierre_is_city))\n# Rule 5: Any city in Butte is not in Pierre\nsolver.add(Implies(butte_is_city, Not(pierre_is_city)))\n\n# Create assertions to check the query\n# Based on the information provided, Pierre and Bismarck are not mentioned to be in the same state\n# Therefore, the answer is Uncertain\nprint(\"C\")  # Uncertain",
      "context": "Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Pierre and Bismarck are in the same state.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_125",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nrock_is_monkey = Bool(\"rock_is_monkey\")\nrock_is_bird = Bool(\"rock_is_bird\")\nrock_flies = Bool(\"rock_flies\")\nrock_breathes = Bool(\"rock_breathes\")\nrock_has_wings = Bool(\"rock_has_wings\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All mammals are animals\nsolver.add(Implies(rock_is_monkey, rock_is_monkey))\n\n# Rule 2: All monkeys are mammals\nsolver.add(Implies(rock_is_monkey, rock_is_monkey))\n\n# Rule 3: An animal is either a monkey or a bird\nsolver.add(Or(rock_is_monkey, rock_is_bird))\n\n# Rule 4: All birds fly\nsolver.add(Implies(rock_is_bird, rock_flies))\n\n# Rule 5: All animals breathe\nsolver.add(Implies(Or(rock_is_monkey, rock_is_bird), rock_breathes))\n\n# Rule 6: If something can fly, then it has wings\nsolver.add(Implies(rock_flies, rock_has_wings))\n\n# Rule 7: If Rock is neither a fly nor a bird, then Rock neither flies nor breathes\nsolver.add(Implies(And(Not(rock_is_bird), Not(rock_flies)), And(Not(rock_flies), Not(rock_breathes)))\n\n# Create assertions to check the query\nsolver.add(rock_is_monkey)\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Rock NOT be a monkey?\nsolver.push()\nsolver.add(Not(rock_is_monkey))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Rock be a monkey?\nsolver.push()\nsolver.add(rock_is_monkey)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Rock is a monkey\nelse:\n    print(\"B\")  # False - Rock is not a monkey",
      "context": "All mammals are animals. All monkeys are mammals. An animal is either a monkey or a bird. All birds fly. All animals breathe. If something can fly, then it has wings. If Rock is neither a fly nor a bird, then Rock neither flies nor breathes.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Rock is a monkey.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_0",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nperform_talent_shows = Bool(\"perform_talent_shows\")\nattend_school_events = Bool(\"attend_school_events\")\nengage_with_events = Bool(\"engage_with_events\")\ninactive_member = Bool(\"inactive_member\")\nchaperone_dances = Bool(\"chaperone_dances\")\nstudent = Bool(\"student\")\nyoung_child = Bool(\"young_child\")\nteenager = Bool(\"teenager\")\nfurther_academic_careers = Bool(\"further_academic_careers\")\nbonnie = Bool(\"bonnie\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If people perform in school talent shows often, then they attend and are very engaged with school events\nsolver.add(Implies(perform_talent_shows, And(attend_school_events, engage_with_events)))\n\n# Rule 2: People either perform in school talent shows often or are inactive and disinterested members of their community\nsolver.add(Or(perform_talent_shows, inactive_member))\n\n# Rule 3: If people chaperone high school dances, then they are not students who attend the school\nsolver.add(Implies(chaperone_dances, Not(student)))\n\n# Rule 4: All people who are inactive and disinterested members of their community chaperone high school dances\nsolver.add(Implies(inactive_member, chaperone_dances))\n\n# Rule 5: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school\nsolver.add(Implies(And(Or(young_child, teenager), further_academic_careers), student))\n\n# Rule 6: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school\nsolver.add(Or(And(attend_school_events, engage_with_events, student), And(Not(attend_school_events), Not(engage_with_events), Not(student))))\n\n# Create assertions to check the query\nsolver.add(perform_talent_shows == bonnie)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(perform_talent_shows))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(perform_talent_shows)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must perform in school talent shows often\nelse:\n    print(\"B\")  # False - cannot perform in school talent shows often",
      "context": "If people perform in school talent shows often, then they attend and are very engaged with school events. People either perform in school talent shows often or are inactive and disinterested members of their community. If people chaperone high school dances, then they are not students who attend the school. All people who are inactive and disinterested members of their community chaperone high school dances. All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school. Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Bonnie performs in school talent shows often.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_17",
      "predicted": "B",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nrock_is_rabbit = Bool(\"rock_is_rabbit\")\nrock_is_squirrel = Bool(\"rock_is_squirrel\")\nrock_is_turtle = Bool(\"rock_is_turtle\")\nrock_is_skittish = Bool(\"rock_is_skittish\")\nrock_is_still = Bool(\"rock_is_still\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All rabbits are cute\nsolver.add(Implies(rock_is_rabbit, rock_is_cute))\n\n# Rule 2: Some turtles exist (no strict constraint needed)\n\n# Rule 3: An animal is either a rabbit or a squirrel\nsolver.add(Or(rock_is_rabbit, rock_is_squirrel))\n\n# Rule 4: If something is skittish, then it is not still\nsolver.add(Implies(rock_is_skittish, Not(rock_is_still)))\n\n# Rule 5: All squirrels are skittish\nsolver.add(Implies(rock_is_squirrel, rock_is_skittish))\n\n# Rule 6: Rock is still\nsolver.add(rock_is_still)\n\n# Create assertions to check the query\n# Check if Rock is not a turtle\nsolver.add(Not(rock_is_turtle))\n\n# Determine if the statement is True, False, or Uncertain\nif solver.check() == sat:\n    print(\"B\")  # False - Rock is not a turtle\nelse:\n    print(\"A\")  # True - Rock is not a turtle",
      "context": "All rabbits are cute. Some turtles exist. An animal is either a rabbit or a squirrel. If something is skittish, then it is not still. All squirrels are skittish. Rock is still.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Rock is not a turtle.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_144",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nbreeding_back = Bool(\"breeding_back\")\nselective_breeding = Bool(\"selective_breeding\")\ndomestic_animals = Bool(\"domestic_animals\")\nheck_cattle = Bool(\"heck_cattle\")\naurochs = Bool(\"aurochs\")\nextinct = Bool(\"extinct\")\nresemble_extinct = Bool(\"resemble_extinct\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Heck cattle are animals\nsolver.add(Implies(heck_cattle, domestic_animals))\n\n# Rule 2: Aurochs are animals\nsolver.add(aurochs == domestic_animals)\n\n# Rule 3: Some animals to be bred-back resemble animals that are extinct\n# We don't add a constraint for \"some\" - it just means both resembling extinct and not resembling extinct are possible\n\n# Rule 4: Breeding back is a form of artificial selection\nsolver.add(Implies(breeding_back, selective_breeding))\n\n# Rule 5: Heck cattle were bred-back in the 1920s to resemble the aurochs\nsolver.add(Implies(And(heck_cattle, aurochs), resemble_extinct))\n\n# Rule 6: Heck cattle were bred-back in the 1920s\nsolver.add(heck_cattle)\n\n# Rule 7: Breeding back is a form of artificial selection\nsolver.add(breeding_back)\n\n# Step 4: Check if the query statement \"Aurochs are extinct\" must be true\n# Test 1: Can Aurochs NOT be extinct?\nsolver.push()\nsolver.add(Not(extinct))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Aurochs be extinct?\nsolver.push()\nsolver.add(extinct)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be extinct\nelse:\n    print(\"B\")  # False - cannot be extinct",
      "context": "Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals. Heck cattle were bred-back in the 1920s to resemble the aurochs. [BG] Heck cattle are animals. [BG] Aurochs are animals. Some animals to be bred-back resemble animals that are extinct.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Aurochs are extinct.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_83",
      "predicted": "B",
      "correct": "B",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nis_spicy = Bool(\"is_spicy\")\nis_bakery = Bool(\"is_bakery\")\nis_cupcake = Bool(\"is_cupcake\")\nis_hotpot = Bool(\"is_hotpot\")\nis_product_of_baked_by_melissa = Bool(\"is_product_of_baked_by_melissa\")\ndried_thai_chilies = Bool(\"dried_thai_chilies\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: No bakery is spicy\nsolver.add(Implies(is_bakery, Not(is_spicy)))\n\n# Rule 2: All cupcakes are bakeries\nsolver.add(Implies(is_cupcake, is_bakery))\n\n# Rule 3: All hotpots are spicy\nsolver.add(Implies(is_hotpot, is_spicy))\n\n# Rule 4: All products of Baked by Melissa are cupcakes\nsolver.add(Implies(is_product_of_baked_by_melissa, is_cupcake))\n\n# Rule 5: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy\nsolver.add(Implies(Or(is_spicy, is_bakery), Or(is_hotpot, is_spicy)))\n\n# Create assertions to check the query\n# Query: Dried Thai chilies are cupcakes and a product of Baked by Melissa\nsolver.add(And(dried_thai_chilies, is_cupcake, is_product_of_baked_by_melissa))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can dried Thai chilies NOT be cupcakes and a product of Baked by Melissa?\nsolver.push()\nsolver.add(Not(And(dried_thai_chilies, is_cupcake, is_product_of_baked_by_melissa)))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can dried Thai chilies be cupcakes and a product of Baked by Melissa?\nsolver.push()\nsolver.add(And(dried_thai_chilies, is_cupcake, is_product_of_baked_by_melissa))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be cupcakes and a product of Baked by Melissa\nelse:\n    print(\"B\")  # False - cannot be cupcakes and a product of Baked by Melissa",
      "context": "No bakery is spicy. All cupcakes are bakeries. All hotpots are spicy. All products of Baked by Melissa are cupcakes. If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Dried Thai chilies are cupcakes and a product of Baked by Melissa.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_13",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nlegend_of_zelda = Bool(\"legend_of_zelda\")\ntop_10_game = Bool(\"top_10_game\")\njapanese_company = Bool(\"japanese_company\")\nmore_than_one_million_copies = Bool(\"more_than_one_million_copies\")\nfifa_22 = Bool(\"fifa_22\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: A Japanese game company created the game the Legend of Zelda\nsolver.add(Implies(legend_of_zelda, japanese_company))\n\n# Rule 2: All games in the Top 10 list are made by Japanese game companies\nsolver.add(Implies(top_10_game, japanese_company))\n\n# Rule 3: If a game sells more than one million copies, then it will be selected into the Top 10 list\nsolver.add(Implies(more_than_one_million_copies, top_10_game))\n\n# Rule 4: The Legend of Zelda sold more than one million copies\nsolver.add(legend_of_zelda)\nsolver.add(more_than_one_million_copies)\n\n# Create assertions to check the query\n# Check if FIFA 22 is made by a Japanese video game company\nsolver.add(Implies(fifa_22, japanese_company))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can FIFA 22 NOT be made by a Japanese video game company?\nsolver.push()\nsolver.add(Not(fifa_22))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can FIFA 22 be made by a Japanese video game company?\nsolver.push()\nsolver.add(fifa_22)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - FIFA 22 is made by a Japanese video game company\nelse:\n    print(\"B\")  # False - FIFA 22 is not made by a Japanese video game company",
      "context": "A Japanese game company created the game the Legend of Zelda. All games in the Top 10 list are made by Japanese game companies. [BG] If a game sells more than one million copies, then it will be selected into the Top 10 list. The Legend of Zelda sold more than one million copies.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? FIFA 22 is made by a Japanese video game company.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_111",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nfir_tree = Bool(\"fir_tree\")\nevergreen = Bool(\"evergreen\")\nobject_of_worship = Bool(\"object_of_worship\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All fir trees are evergreens\nsolver.add(Implies(fir_tree, evergreen))\n\n# Rule 2: Some objects of worship are fir trees\n# We don't add a constraint for \"some\" - it just means both object of worship and not object of worship are possible\n\n# Create assertions to check the query\n# Query: Some evergreens are not objects of worship\n# This is equivalent to saying that there exists an evergreen that is not an object of worship\n# We will check if it's possible for an evergreen to not be an object of worship\n\nsolver.push()\nsolver.add(Not(Implies(evergreen, object_of_worship)))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_false:\n    print(\"C\")  # Uncertain - it's possible for some evergreens to not be objects of worship\nelse:\n    print(\"B\")  # False - it's not possible for some evergreens to not be objects of worship",
      "context": "All fir trees are evergreens. Some objects of worship are fir trees.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Some evergreens are not objects of worship.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_107",
      "predicted": "A",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ncosts_205 = Bool(\"costs_205\")\nprovides_financial_aid = Bool(\"provides_financial_aid\")\neconomic_hardship = Bool(\"economic_hardship\")\ntom = Bool(\"tom\")\nsingle_parent_family = Bool(\"single_parent_family\")\ndad_out_of_work = Bool(\"dad_out_of_work\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: It costs US $205 to take the GRE test\n# Rule 2: ETS provides financial aid to those GRE applicants who prove economic hardship\nsolver.add(Implies(economic_hardship, provides_financial_aid))\n\n# Rule 3: Economic hardship refers to difficulty caused by having too little money or too few resources\n\n# Rule 4: Tom lives in a single-parent family\n# Rule 5: His dad has been out of work for more than a year\nsolver.add(And(single_parent_family, dad_out_of_work))\n\n# Create assertions to check the query\n# Rule 6: There is no financial aid available for the GRE test\nsolver.add(Not(provides_financial_aid))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can there be financial aid available for the GRE test?\nsolver.push()\nsolver.add(provides_financial_aid)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can there be no financial aid available for the GRE test?\nsolver.push()\nsolver.add(Not(provides_financial_aid))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and not can_be_false:\n    print(\"B\")  # False - financial aid is available\nelif not can_be_true and can_be_false:\n    print(\"A\")  # True - no financial aid available\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "It costs US $205 to take the GRE test. ETS provides financial aid to those GRE applicants who prove economic hardship. Economic hardship refers to difficulty caused by having too little money or too few resources. Tom lives in a single-parent family. His dad has been out of work for more than a year.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? There is no financial aid available for the GRE test.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_89",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nbooks_contain_knowledge = Bool(\"books_contain_knowledge\")\nperson_gains_knowledge = Bool(\"person_gains_knowledge\")\nperson_becomes_smarter = Bool(\"person_becomes_smarter\")\nharry_read_walden = Bool(\"harry_read_walden\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Books contain tons of knowledge\nsolver.add(Implies(books_contain_knowledge, person_gains_knowledge))\n\n# Rule 2: When a person reads a book, that person gains knowledge\nsolver.add(Implies(harry_read_walden, person_gains_knowledge))\n\n# Rule 3: If a person gains knowledge, they become smarter\nsolver.add(Implies(person_gains_knowledge, person_becomes_smarter))\n\n# Rule 4: Harry read the book “Walden” by Henry Thoreau (fact)\nsolver.add(harry_read_walden)\n\n# Create assertions to check the query\n# Check if Harry is smarter than before\nsolver.push()\nsolver.add(Not(person_becomes_smarter))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(person_becomes_smarter)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Harry is smarter than before\nelse:\n    print(\"B\")  # False - Harry is not smarter than before",
      "context": "[BG] Books contain tons of knowledge. [BG] When a person reads a book, that person gains knowledge. [BG] If a person gains knowledge, they become smarter. Harry read the book “Walden” by Henry Thoreau.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Harry is smarter than before.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_130",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\njohn_has_wedding = Bool(\"john_has_wedding\")\njohn_has_child = Bool(\"john_has_child\")\njohn_travels_paris_honeymoon = Bool(\"john_travels_paris_honeymoon\")\njohn_wedding_in_july = Bool(\"john_wedding_in_july\")\njohn_wedding_well_attended = Bool(\"john_wedding_well_attended\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All people who have a wedding are people who have at least one child\nsolver.add(Implies(john_has_wedding, john_has_child))\n\n# Rule 2: All people who travel to Paris for their honeymoon are people who have a wedding\nsolver.add(Implies(john_travels_paris_honeymoon, john_has_wedding))\n\n# Rule 3: All weddings that occur in July belong to people who travel to Paris for their honeymoon\nsolver.add(Implies(john_wedding_in_july, john_travels_paris_honeymoon))\n\n# Rule 4: Some weddings in July are well-attended\n# We don't add a constraint for \"some\" - it just means both well-attended and not well-attended are possible\n\n# Rule 5: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding\nsolver.add(Implies(john_has_child, And(Not(john_travels_paris_honeymoon), Not(john_has_wedding))))\n\n# Rule 6: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon\nsolver.add(Implies(john_wedding_well_attended, Or(john_wedding_in_july, john_travels_paris_honeymoon)))\n\n# Create assertions to check the query\nsolver.add(john_has_child)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(john_has_child))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(john_has_child)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must have at least one child\nelse:\n    print(\"B\")  # False - cannot have at least one child",
      "context": "All people who have a wedding are people who have at least one child. All people who travel to Paris for their honeymoon are people who have a wedding. All weddings that occur in July belong to people who travel to Paris for their honeymoon. Some weddings in July are well-attended. If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding. If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? John has at least one child.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_126",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nrock_is_mammal = Bool(\"rock_is_mammal\")\nrock_is_monkey = Bool(\"rock_is_monkey\")\nrock_is_bird = Bool(\"rock_is_bird\")\nrock_flies = Bool(\"rock_flies\")\nrock_breathes = Bool(\"rock_breathes\")\nrock_has_wings = Bool(\"rock_has_wings\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All mammals are animals\nsolver.add(Implies(rock_is_mammal, rock_is_animal))\n\n# Rule 2: All monkeys are mammals\nsolver.add(Implies(rock_is_monkey, rock_is_mammal))\n\n# Rule 3: An animal is either a monkey or a bird\nsolver.add(Or(rock_is_monkey, rock_is_bird))\n\n# Rule 4: All birds fly\nsolver.add(Implies(rock_is_bird, rock_flies))\n\n# Rule 5: All animals breathe\nsolver.add(Implies(rock_is_animal, rock_breathes))\n\n# Rule 6: If something can fly, then it has wings\nsolver.add(Implies(rock_flies, rock_has_wings))\n\n# Rule 7: If Rock is neither a fly nor a bird, then Rock neither flies nor breathes\nsolver.add(Implies(And(Not(rock_is_fly), Not(rock_is_bird)), And(Not(rock_flies), Not(rock_breathes)))\n\n# Create assertions to check the query\nsolver.add(rock_has_wings)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(rock_has_wings))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(rock_has_wings)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Rock has wings\nelse:\n    print(\"B\")  # False - Rock does not have wings",
      "context": "All mammals are animals. All monkeys are mammals. An animal is either a monkey or a bird. All birds fly. All animals breathe. If something can fly, then it has wings. If Rock is neither a fly nor a bird, then Rock neither flies nor breathes.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Rock has wings.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_134",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nsome_mammals_have_teeth = Bool(\"some_mammals_have_teeth\")\nplatypus_have_no_teeth = Bool(\"platypus_have_no_teeth\")\nplatypus_are_mammals = Bool(\"platypus_are_mammals\")\nhumans_have_teeth = Bool(\"humans_have_teeth\")\nhumans_are_mammals = Bool(\"humans_are_mammals\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Some mammals have teeth\n# We don't add a constraint for \"some\" - it just means both having teeth and not having teeth are possible\n\n# Rule 2: Platypus have no teeth\nsolver.add(Not(platypus_have_no_teeth))\n\n# Rule 3: Platypus are mammals\nsolver.add(Implies(platypus_are_mammals, platypus_have_no_teeth))\n\n# Rule 4: Humans have teeth\nsolver.add(humans_have_teeth)\n\n# Create assertions to check the query\n# Rule 5: Humans are mammals\nsolver.add(Implies(humans_are_mammals, humans_have_teeth))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Humans NOT be mammals?\nsolver.push()\nsolver.add(Not(humans_are_mammals))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Humans be mammals?\nsolver.push()\nsolver.add(humans_are_mammals)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Humans are mammals\nelse:\n    print(\"B\")  # False - Humans are not mammals",
      "context": "[BG] Some mammals have teeth. Platypus have no teeth. Platypus are mammals. Humans have teeth.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Humans are mammals.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_60",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nbillings_is_city = Bool(\"billings_is_city\")\nmontana_includes_butte = Bool(\"montana_includes_butte\")\nmontana_includes_helena = Bool(\"montana_includes_helena\")\nmontana_includes_missoula = Bool(\"montana_includes_missoula\")\nwhite_sulphur_springs_is_city = Bool(\"white_sulphur_springs_is_city\")\nbutte_is_city = Bool(\"butte_is_city\")\npierre_is_city = Bool(\"pierre_is_city\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Billings is a city in Montana\nsolver.add(Implies(billings_is_city, montana_includes_butte))\n# Rule 2: Montana includes the cities of Butte, Helena, and Missoula\nsolver.add(And(montana_includes_butte, montana_includes_helena, montana_includes_missoula))\n# Rule 3: White Sulphur Springs and Butte are cities in the same state\nsolver.add(Implies(white_sulphur_springs_is_city, butte_is_city))\n# Rule 4: The city of Pierre is not in Montana\nsolver.add(Not(pierre_is_city))\n# Rule 5: Any city in Butte is not in Pierre\nsolver.add(Implies(butte_is_city, Not(pierre_is_city)))\n\n# Create assertions to check the query\n# Check if Montana is home to the city of Missoula\nsolver.add(montana_includes_missoula)\n\n# Determine if the statement is True, False, or Uncertain\nif solver.check() == sat:\n    print(\"A\")  # True\nelse:\n    print(\"B\")  # False",
      "context": "Billings is a city in Montana. Montana includes the cities of Butte, Helena, and Missoula. White Sulphur Springs and Butte are cities in the same state. The city of Pierre is not in Montana. Any city in Butte is not in Pierre.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Montana is home to the city of Missoula.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_51",
      "predicted": "B",
      "correct": "A",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nno_digital_media = Bool(\"no_digital_media\")\nanalog = Bool(\"analog\")\nprinted_text = Bool(\"printed_text\")\ndigital = Bool(\"digital\")\nstreaming_services = Bool(\"streaming_services\")\nhardcover_book = Bool(\"hardcover_book\")\nis_1984 = Bool(\"is_1984\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: No digital media are analog\nsolver.add(Implies(digital, Not(analog)))\n\n# Rule 2: Every printed text is analog\nsolver.add(Implies(printed_text, analog))\n\n# Rule 3: All streaming services are digital\nsolver.add(Implies(streaming_services, digital))\n\n# Rule 4: If an object is a hardcover book then it is printed text\nsolver.add(Implies(hardcover_book, printed_text))\n\n# Rule 5: If 1984 is a streaming service, then 1984 is a hardcover book\nsolver.add(Implies(is_1984, hardcover_book))\n\n# Create assertions to check the query\n# Check if the statement \"1984 is not a streaming service\" must be True\nsolver.push()\nsolver.add(is_1984)\nsolver.add(Not(streaming_services))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Check if the statement \"1984 is not a streaming service\" must be False\nsolver.push()\nsolver.add(is_1984)\nsolver.add(streaming_services)\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and not can_be_false:\n    print(\"B\")  # False - 1984 is a streaming service\nelif not can_be_true and can_be_false:\n    print(\"A\")  # True - 1984 is not a streaming service\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "No digital media are analog. Every printed text is analog. All streaming services are digital. If an object is a hardcover book then it is printed text. If 1984 is a streaming service, then 1984 is a hardcover book.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? 1984 is not a streaming service.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_25",
      "predicted": "B",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nbeijing_is_capital = Bool(\"beijing_is_capital\")\nbeijing_is_populous = Bool(\"beijing_is_populous\")\nbeijing_is_northern = Bool(\"beijing_is_northern\")\nbeijing_hosted_2008 = Bool(\"beijing_hosted_2008\")\nbeijing_hosted_both = Bool(\"beijing_hosted_both\")\nbeijing_universities_rank = Bool(\"beijing_universities_rank\")\nbeijing_is_southern = Bool(\"beijing_is_southern\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Beijing is the capital of the People's Republic of China\nsolver.add(beijing_is_capital)\n\n# Rule 2: Beijing is the world's most populous national capital city\nsolver.add(beijing_is_populous)\n\n# Rule 3: Beijing is located in Northern China\nsolver.add(beijing_is_northern)\n\n# Rule 4: Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games\nsolver.add(beijing_hosted_2008)\n\n# Rule 5: Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics\nsolver.add(beijing_hosted_both)\n\n# Rule 6: Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world\nsolver.add(beijing_universities_rank)\n\n# Create assertions to check the query\n# Check if Beijing is located in southern China\nsolver.add(Not(beijing_is_southern))\n\n# Determine if the statement is True, False, or Uncertain\nif solver.check() == sat:\n    print(\"B\")  # False - Beijing is not located in southern China\nelse:\n    print(\"C\")  # Uncertain - it's not explicitly stated that Beijing is located in southern China",
      "context": "Beijing is the capital of the People's Republic of China. Beijing is the world's most populous national capital city. Beijing is located in Northern China. Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games. Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Beijing is located in southern China.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_101",
      "predicted": "C",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nman_is_kind = Bool(\"man_is_kind\")\nman_is_evil = Bool(\"man_is_evil\")\nugly_person_is_handsome = Bool(\"ugly_person_is_handsome\")\nevil_people_are_ugly = Bool(\"evil_people_are_ugly\")\ngentlemen_are_handsome = Bool(\"gentlemen_are_handsome\")\nceos_are_gentlemen = Bool(\"ceos_are_gentlemen\")\nharry_is_gentleman = Bool(\"harry_is_gentleman\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: A man is either kind or evil\nsolver.add(Or(man_is_kind, man_is_evil))\n\n# Rule 2: No ugly person is handsome\nsolver.add(Implies(ugly_person_is_handsome, Not(evil_people_are_ugly)))\n\n# Rule 3: All evil people are ugly\nsolver.add(Implies(evil_people_are_ugly, man_is_evil))\n\n# Rule 4: All gentlemen are handsome\nsolver.add(Implies(gentlemen_are_handsome, harry_is_gentleman))\n\n# Rule 5: All CEOs are gentlemen\nsolver.add(Implies(ceos_are_gentlemen, gentlemen_are_handsome))\n\n# Rule 6: Harry is a gentleman\nsolver.add(harry_is_gentleman)\n\n# Create assertions to check the query\n# If Harry is either both evil and ugly, or neither evil nor ugly, then Harry is neither kind nor a CEO\n# Harry is either both evil and ugly\nsolver.add(Implies(And(harry_is_gentleman, man_is_evil, evil_people_are_ugly), Not(Or(man_is_kind, ceos_are_gentlemen))))\n# Or neither evil nor ugly\nsolver.add(Implies(And(harry_is_gentleman, Not(man_is_evil), Not(evil_people_are_ugly)), Not(Or(man_is_kind, ceos_are_gentlemen)))\n\n# Determine if the statement is True, False, or Uncertain\n# Check if the query statement must be True\nsolver.push()\nsolver.add(Not(Not(Or(man_is_kind, ceos_are_gentlemen))))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Check if the query statement must be False\nsolver.push()\nsolver.add(Or(man_is_kind, ceos_are_gentlemen))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be true\nelse:\n    print(\"B\")  # False - cannot be true",
      "context": "A man is either kind or evil. No ugly person is handsome. All evil people are ugly. All gentlemen are handsome. All CEOs are gentlemen. Harry is a gentleman.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? If Harry is either both evil and ugly, or neither evil nor ugly, then Harry is neither kind nor a CEO.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_48",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nspring = Bool(\"spring\")\nsummer = Bool(\"summer\")\nfall = Bool(\"fall\")\nwinter = Bool(\"winter\")\nemma = Bool(\"emma\")\nmia = Bool(\"mia\")\njames = Bool(\"james\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All students who want to have a long vacation love summer the most\nsolver.add(Implies(james, summer))\n\n# Rule 2: Emma's favorite season is summer\nsolver.add(emma == summer)\n\n# Rule 3: Mia's favorite season is not the same as Emma's\nsolver.add(Not(mia == emma))\n\n# Rule 4: There are four seasons in a year: Spring, Summer, Fall, and Winter\n# We don't need to add constraints for each season as it's not necessary for this query\n\n# Create assertions to check the query\nsolver.add(mia == spring)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(spring))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(spring)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Mia's favorite season is spring\nelse:\n    print(\"B\")  # False - Mia's favorite season is not spring",
      "context": "[BG] There are four seasons in a year: Spring, Summer, Fall, and Winter. All students who want to have a long vacation love summer the most. Emma's favorite season is summer. Mia's favorite season is not the same as Emma's. James wants to have a long vacation.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Mia's favorite season is spring.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_49",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ndigital_media = Bool(\"digital_media\")\nanalog = Bool(\"analog\")\nprinted_text = Bool(\"printed_text\")\nstreaming_services = Bool(\"streaming_services\")\nhardcover_book = Bool(\"hardcover_book\")\nnineteen_eighty_four = Bool(\"nineteen_eighty_four\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: No digital media are analog\nsolver.add(Implies(digital_media, Not(analog)))\n\n# Rule 2: Every printed text is analog\nsolver.add(Implies(printed_text, analog))\n\n# Rule 3: All streaming services are digital\nsolver.add(Implies(streaming_services, digital_media))\n\n# Rule 4: If an object is a hardcover book then it is printed text\nsolver.add(Implies(hardcover_book, printed_text))\n\n# Rule 5: If 1984 is a streaming service, then 1984 is a hardcover book\nsolver.add(Implies(nineteen_eighty_four, hardcover_book))\n\n# Create assertions to check the query\nsolver.add(nineteen_eighty_four)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(printed_text))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(printed_text)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be printed text\nelse:\n    print(\"B\")  # False - cannot be printed text",
      "context": "No digital media are analog. Every printed text is analog. All streaming services are digital. If an object is a hardcover book then it is printed text. If 1984 is a streaming service, then 1984 is a hardcover book.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? 1984 is printed text.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_66",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nyale_university = Bool(\"yale_university\")\nprivate_ivy_league = Bool(\"private_ivy_league\")\nmoved_to_new_haven = Bool(\"moved_to_new_haven\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Yale University is a private Ivy League research university\nsolver.add(Implies(yale_university, private_ivy_league))\n\n# Rule 2: Yale University moved to New Haven in 1716\nsolver.add(Implies(yale_university, moved_to_new_haven))\n\n# Rule 3: Yale University's endowment was valued at $42.3 billion (fact)\n\n# Rule 4: Yale University has been organized into 27 constituent colleges and schools\n# Rule 5: List of residential colleges at Yale\nbenjamin_franklin_college = Bool(\"benjamin_franklin_college\")\nberkeley_college = Bool(\"berkeley_college\")\nbranford_college = Bool(\"branford_college\")\ndavenport_college = Bool(\"davenport_college\")\nezra_stiles_college = Bool(\"ezra_stiles_college\")\ngrace_hopper_college = Bool(\"grace_hopper_college\")\njonathan_edwards_college = Bool(\"jonathan_edwards_college\")\nmorse_college = Bool(\"morse_college\")\npauli_murray_college = Bool(\"pauli_murray_college\")\npierson_college = Bool(\"pierson_college\")\nsaybrook_college = Bool(\"saybrook_college\")\nsilliman_college = Bool(\"silliman_college\")\ntimothy_dwight_college = Bool(\"timothy_dwight_college\")\ntrumbull_college = Bool(\"trumbull_college\")\n\n# Create assertions to check the query\n# Check if the query statement \"A private Ivy League research university moved to New Haven\" must be true\nsolver.push()\nsolver.add(private_ivy_league)\nsolver.add(moved_to_new_haven)\nsolver.add(Not(yale_university))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Check if the query statement \"A private Ivy League research university moved to New Haven\" must be false\nsolver.push()\nsolver.add(Not(private_ivy_league))\nsolver.add(Not(moved_to_new_haven))\nsolver.add(yale_university)\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be a private Ivy League research university that moved to New Haven\nelif not can_be_true and can_be_false:\n    print(\"B\")  # False - cannot be a private Ivy League research university that moved to New Haven\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "Yale University is a private Ivy League research university. Yale University moved to New Haven in 1716. Yale university's endowment was valued at $42.3 billion. Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools. A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? A private Ivy League research university moved to New Haven.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_44",
      "predicted": "B",
      "correct": "B",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nplayer = Bool(\"player\")\nranked_highly = Bool(\"ranked_highly\")\nmost_active = Bool(\"most_active\")\nlost_to_iga = Bool(\"lost_to_iga\")\nfemale_roland_garros = Bool(\"female_roland_garros\")\nmale_roland_garros = Bool(\"male_roland_garros\")\nlost_to_rafael = Bool(\"lost_to_rafael\")\ncoco_gauff = Bool(\"coco_gauff\")\nnot_male_roland_garros = Bool(\"not_male_roland_garros\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis\nsolver.add(Implies(ranked_highly, most_active))\n\n# Rule 2: Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association\nsolver.add(Implies(lost_to_iga, ranked_highly))\n\n# Rule 3: All female tennis players at Roland Garros 2022 lost to Iga Świątek\nsolver.add(Implies(female_roland_garros, lost_to_iga))\n\n# Rule 4: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022\nsolver.add(Or(female_roland_garros, male_roland_garros))\n\n# Rule 5: All male tennis players at Roland Garros 2022 lost to Rafael Nadal\nsolver.add(Implies(male_roland_garros, lost_to_rafael))\n\n# Rule 6: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022\nsolver.add(Implies(Or(ranked_highly, lost_to_rafael), not_male_roland_garros))\n\n# Create assertions to check the query\nsolver.add(Not(And(lost_to_iga, most_active)))\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(Not(And(lost_to_iga, most_active))))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(And(lost_to_iga, most_active))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be true\nelse:\n    print(\"B\")  # False - cannot be true",
      "context": "If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis. Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association. All female tennis players at Roland Garros 2022 lost to Iga Świątek. Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022. All male tennis players at Roland Garros 2022 lost to Rafael Nadal. If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Coco Gauff is not a player who lost to Iga Świątek or one of the most active players in major tennis.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_172",
      "predicted": "A",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ndeadly_disease = Bool(\"deadly_disease\")\nlow_survival_rate = Bool(\"low_survival_rate\")\nsevere_cancer = Bool(\"severe_cancer\")\nbile_duct_cancer = Bool(\"bile_duct_cancer\")\ncholangiocarcinoma = Bool(\"cholangiocarcinoma\")\nmild_flu = Bool(\"mild_flu\")\ncolorectal_cancer = Bool(\"colorectal_cancer\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If something is a deadly disease, then its survival rate is low\nsolver.add(Implies(deadly_disease, low_survival_rate))\n\n# Rule 2: All severe cancers are deadly diseases\nsolver.add(Implies(severe_cancer, deadly_disease))\n\n# Rule 3: Bile duct cancer is a severe cancer\nsolver.add(Implies(bile_duct_cancer, severe_cancer))\n\n# Rule 4: All Cholangiocarcinoma is bile duct cancer\nsolver.add(Implies(cholangiocarcinoma, bile_duct_cancer))\n\n# Rule 5: No one with mild flu has a low survival rate\nsolver.add(Implies(mild_flu, Not(low_survival_rate)))\n\n# Rule 6: If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer\nsolver.add(Implies(And(colorectal_cancer, low_survival_rate), Not(colorectal_cancer)))\n\n# Create assertions to check the query\n# Query: If colorectal cancer is not a mild flu and a Cholangiocarcinoma, then colorectal cancer is a bile duct cancer or a Cholangiocarcinoma\nsolver.add(Implies(And(Not(colorectal_cancer), Not(mild_flu), Not(cholangiocarcinoma)), Or(bile_duct_cancer, cholangiocarcinoma)))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can the query be False?\nsolver.push()\nsolver.add(Not(Implies(And(Not(colorectal_cancer), Not(mild_flu), Not(cholangiocarcinoma)), Or(bile_duct_cancer, cholangiocarcinoma))))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can the query be True?\nsolver.push()\nsolver.add(Implies(And(Not(colorectal_cancer), Not(mild_flu), Not(cholangiocarcinoma)), Or(bile_duct_cancer, cholangiocarcinoma)))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and not can_be_false:\n    print(\"A\")  # True\nelif not can_be_true and can_be_false:\n    print(\"B\")  # False\nelse:\n    print(\"C\")  # Uncertain",
      "context": "If something is a deadly disease, then its survival rate is low. All severe cancers are deadly diseases. Bile duct cancer is a severe cancer. All Cholangiocarcinoma is bile duct cancer. No one with mild flu has a low survival rate. If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? If colorectal cancer is not a mild flu and a Cholangiocarcinoma, then colorectal cancer is a bile duct cancer or a Cholangiocarcinoma.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_8",
      "predicted": "B",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nmonkeypox = Bool(\"monkeypox\")\nmonkeypox_virus = Bool(\"monkeypox_virus\")\nanimals = Bool(\"animals\")\nhumans = Bool(\"humans\")\nmammals = Bool(\"mammals\")\nsymptoms = Bool(\"symptoms\")\nfever = Bool(\"fever\")\nheadache = Bool(\"headache\")\nmuscle_pains = Bool(\"muscle_pains\")\nfeeling_tired = Bool(\"feeling_tired\")\ncoughing = Bool(\"coughing\")\nget_a_glu = Bool(\"get_a_glu\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Monkeypox is an infectious disease caused by the monkeypox virus\nsolver.add(Implies(monkeypox, monkeypox_virus))\n\n# Rule 2: Monkeypox virus can occur in certain animals, including humans\nsolver.add(Implies(monkeypox_virus, And(animals, humans)))\n\n# Rule 3: Humans are mammals\nsolver.add(Implies(humans, mammals))\n\n# Rule 4: Mammals are animals\nsolver.add(Implies(mammals, animals))\n\n# Rule 5: Symptoms of Monkeypox include fever, headache, muscle pains, feeling tired\nsolver.add(Implies(symptoms, And(fever, headache, muscle_pains, feeling_tired)))\n\n# Rule 6: People feel tired when they get a glu\nsolver.add(Implies(get_a_glu, feeling_tired))\n\n# Create assertions to check the query\n# Check if the symptoms of Monkeypox include coughing\nsolver.add(Not(coughing))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can symptoms of Monkeypox include coughing?\nsolver.push()\nsolver.add(coughing)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can symptoms of Monkeypox NOT include coughing?\nsolver.push()\nsolver.add(Not(coughing))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - symptoms of Monkeypox include coughing\nelse:\n    print(\"B\")  # False - symptoms of Monkeypox do not include coughing",
      "context": "Monkeypox is an infectious disease caused by the monkeypox virus. Monkeypox virus can occur in certain animals, including humans. Humans are mammals. Mammals are animals. Symptons of Monkeypox include fever, headache, muscle pains, feeling tired, and so on. People feel tired when they get a glu.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Symptons of Monkeypox include coughing.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_22",
      "predicted": "C",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nstranger_things_is_popular = Bool(\"stranger_things_is_popular\")\nnetflix_show_is_popular = Bool(\"netflix_show_is_popular\")\nkaren_binge_watches = Bool(\"karen_binge_watches\")\nkaren_downloads = Bool(\"karen_downloads\")\nblack_mirror_is_netflix_show = Bool(\"black_mirror_is_netflix_show\")\nkaren_shares_to_lisa = Bool(\"karen_shares_to_lisa\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: \"Stranger Things\" is a popular Netflix show\nsolver.add(stranger_things_is_popular)\n\n# Rule 2: If a Netflix show is popular, Karen will binge-watch it\nsolver.add(Implies(netflix_show_is_popular, karen_binge_watches))\n\n# Rule 3: If and only if Karen binge-watches a Netflix show, she will download it\nsolver.add(Implies(karen_binge_watches, karen_downloads))\nsolver.add(Implies(karen_downloads, karen_binge_watches))\n\n# Rule 4: Karen does not download \"Black Mirror\"\nsolver.add(Not(karen_downloads))\n\n# Rule 5: \"Black Mirror\" is a Netflix show\nsolver.add(black_mirror_is_netflix_show)\n\n# Rule 6: If Karen binge-watches a Netflix show, she will share it to Lisa\nsolver.add(Implies(karen_binge_watches, karen_shares_to_lisa))\n\n# Create assertions to check the query\n# Check if \"Black Mirror\" is popular\nsolver.push()\nsolver.add(Not(stranger_things_is_popular))\nsolver.add(Not(netflix_show_is_popular))\nsolver.add(Not(karen_binge_watches))\nsolver.add(Not(karen_downloads))\nsolver.add(black_mirror_is_netflix_show)\nsolver.add(Not(karen_shares_to_lisa))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_false:\n    print(\"B\")  # False - \"Black Mirror\" is not popular\nelse:\n    print(\"C\")  # Uncertain - it's not clear if \"Black Mirror\" is popular",
      "context": "\"Stranger Things\" is a popular Netflix show. If a Netflix show is popular, Karen will binge-watch it. If and only if Karen binge-watches a Netflix show, she will download it. Karen does not download \"Black Mirror\". \"Black Mirror\" is a Netflix show. If Karen binge-watches a Netflix show, she will share it to Lisa.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? \"Black Mirror\" is popular.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_200",
      "predicted": "A",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nailton_silva = Bool(\"ailton_silva\")\nfootball_player = Bool(\"football_player\")\nloaned_out_to_braga = Bool(\"loaned_out_to_braga\")\nbrazillian_footballer = Bool(\"brazillian_footballer\")\nplays_for_nautico = Bool(\"plays_for_nautico\")\nfootball_club = Bool(\"football_club\")\nbraga = Bool(\"braga\")\nnautico = Bool(\"nautico\")\nfluminense = Bool(\"fluminense\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Ailton Silva is a football player\nsolver.add(Implies(ailton_silva, football_player))\n\n# Rule 2: Ailton Silva was loaned out to Braga\nsolver.add(Implies(ailton_silva, loaned_out_to_braga))\n\n# Rule 3: Ailton Silva is a Brazillian footballer who plays for Nautico\nsolver.add(Implies(ailton_silva, And(brazillian_footballer, plays_for_nautico)))\n\n# Rule 4: Nautico and Braga are football clubs\nsolver.add(And(Implies(nautico, football_club), Implies(braga, football_club)))\n\n# Rule 5: Fluminense is a football club\nsolver.add(fluminense)\n\n# Create assertions to check the query\n# Query: Ailton Silva does not play for a football club\nsolver.add(Not(plays_for_nautico))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Ailton Silva play for a football club?\nsolver.push()\nsolver.add(plays_for_nautico)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Ailton Silva NOT play for a football club?\nsolver.push()\nsolver.add(Not(plays_for_nautico))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and not can_be_false:\n    print(\"B\")  # False - Ailton Silva plays for a football club\nelif not can_be_true and can_be_false:\n    print(\"A\")  # True - Ailton Silva does not play for a football club\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "Ailton Silva, born in 1995, is commonly known as Ailton. Ailton is a football player who was loaned out to Braga. Ailton Silva is a Brazillian footballer who plays for Nautico. Nautico is a football club along with Braga. Fluminense is a football club.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Ailton Silva foes not play for a football club.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_178",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nolympic_games_is_sporting_event = Bool(\"olympic_games_is_sporting_event\")\nlast_olympic_games_was_in_tokyo = Bool(\"last_olympic_games_was_in_tokyo\")\nunited_states_won_most_medals_in_tokyo = Bool(\"united_states_won_most_medals_in_tokyo\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: The Olympic games is a sporting event\nsolver.add(Implies(olympic_games_is_sporting_event, True))\n\n# Rule 2: The last Olympic games was in Tokyo\nsolver.add(last_olympic_games_was_in_tokyo)\n\n# Rule 3: The United States won the most medals in Tokyo\nsolver.add(united_states_won_most_medals_in_tokyo)\n\n# Create assertions to check the query\n# Test 1: Can the United States NOT have won the most medals in the last Olympic games?\nsolver.push()\nsolver.add(Not(united_states_won_most_medals_in_tokyo))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can the United States have won the most medals in the last Olympic games?\nsolver.push()\nsolver.add(united_states_won_most_medals_in_tokyo)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and not can_be_false:\n    print(\"A\")  # True - the United States won the most medals in the last Olympic games\nelif not can_be_true and can_be_false:\n    print(\"B\")  # False - the United States did not win the most medals in the last Olympic games\nelse:\n    print(\"C\")  # Uncertain - it is not clear if the United States won the most medals in the last Olympic games",
      "context": "[BG] The Olympic games is a sporting event. The last Olympic games was in Tokyo. The United States won the most medals in Tokyo.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? The United States won the most medals in the last Olympic games.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_85",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nrestaurant_listed_in_yelp = Bool(\"restaurant_listed_in_yelp\")\nrestaurant_negative_reviews = Bool(\"restaurant_negative_reviews\")\nrestaurant_rating_gt_9 = Bool(\"restaurant_rating_gt_9\")\nrestaurant_provide_takeout = Bool(\"restaurant_provide_takeout\")\nrestaurant_popular_among_locals = Bool(\"restaurant_popular_among_locals\")\nsubway = Bool(\"subway\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews\nsolver.add(Implies(restaurant_listed_in_yelp, Not(restaurant_negative_reviews)))\n\n# Rule 2: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations\nsolver.add(Implies(restaurant_rating_gt_9, restaurant_listed_in_yelp))\n\n# Rule 3: Some restaurants that do not provide take-out service receive many negative reviews\n# We don't add a constraint for \"some\" - it just means both take-out and not take-out are possible\n\n# Rule 4: All restaurants that are popular among local residents have ratings greater than 9\nsolver.add(Implies(restaurant_popular_among_locals, restaurant_rating_gt_9))\n\n# Rule 5: Subway has a rating greater than 9 or is popular among local residents\nsolver.add(Or(subway, restaurant_popular_among_locals))\n\n# Create assertions to check the query\n# Query: Subway provides take-out service and does not receive many negative reviews\nsolver.add(restaurant_provide_takeout)\nsolver.add(Not(restaurant_negative_reviews))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Subway NOT provide take-out service and NOT receive many negative reviews?\nsolver.push()\nsolver.add(Not(restaurant_provide_takeout))\nsolver.add(restaurant_negative_reviews)\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Subway provide take-out service and NOT receive many negative reviews?\nsolver.push()\nsolver.add(restaurant_provide_takeout)\nsolver.add(Not(restaurant_negative_reviews))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Subway can provide take-out service and not receive many negative reviews\nelse:\n    print(\"B\")  # False - Subway cannot provide take-out service and not receive many negative reviews",
      "context": "If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews. All restaurants with a rating greater than 9 are listed in Yelp’s recommendations. Some restaurants that do not provide take-out service receive many negative reviews. All restaurants that are popular among local residents have ratings greater than 9. Subway has a rating greater than 9 or is popular among local residents.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Subway provides take-out service and does not receive many negative reviews.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_73",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ngrowth_companies_stocks = Bool(\"growth_companies_stocks\")\nvolatile_stock = Bool(\"volatile_stock\")\nretirement_fund_suitable = Bool(\"retirement_fund_suitable\")\nmature_companies_stocks = Bool(\"mature_companies_stocks\")\nKO = Bool(\"KO\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All growth companies’ stocks are volatile\nsolver.add(Implies(growth_companies_stocks, volatile_stock))\n\n# Rule 2: If the stock price is volatile, then it is not suitable for a retirement fund\nsolver.add(Implies(volatile_stock, Not(retirement_fund_suitable)))\n\n# Rule 3: Some companies’ stocks are growth companies’ stocks\n# This means it's POSSIBLE, not required, so no strict constraint needed\n\n# Rule 4: All mature companies’ stocks are suitable for a retirement fund\nsolver.add(Implies(mature_companies_stocks, retirement_fund_suitable))\n\n# Rule 5: KO is a mature company’s stock\nsolver.add(KO == mature_companies_stocks)\n\n# Create assertions to check the query\n# Query: If KO is a growth company’s stock or if its price is volatile, then KO is neither a company’s stock nor is its price volatile\nquery = Not(Or(And(KO, growth_companies_stocks), And(KO, volatile_stock)))\n\n# Determine if the statement is True, False, or Uncertain\nsolver.add(Not(query))  # Check if the query must be False\nif solver.check() == unsat:\n    print(\"A\")  # True - the statement must be False\nelse:\n    solver.add(query)  # Check if the query must be True\n    if solver.check() == unsat:\n        print(\"B\")  # False - the statement must be True\n    else:\n        print(\"C\")  # Uncertain - neither True nor False",
      "context": "All growth companies’ stocks are volatile. If the stock price is volatile, then it is not suitable for a retirement fund. Some companies’ stocks are growth companies’ stocks. All mature companies’ stocks are suitable for a retirement fund. KO is a mature company’s stock.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? If KO is a growth company’s stock or if its price is volatile, then KO is neither a company’s stock nor is its price volatile.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_196",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nanimal_barks = Bool(\"animal_barks\")\njane_likes = Bool(\"jane_likes\")\ndog = Bool(\"dog\")\nanimal_jumps = Bool(\"animal_jumps\")\nanimal_has_legs = Bool(\"animal_has_legs\")\nanimal_terricolous = Bool(\"animal_terricolous\")\nkiki = Bool(\"kiki\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If an animal barks, then Jane does not like it\nsolver.add(Implies(animal_barks, Not(jane_likes)))\n\n# Rule 2: All dogs are animals that bark\nsolver.add(Implies(dog, animal_barks))\n\n# Rule 3: If an animal jumps, then Jane likes it\nsolver.add(Implies(animal_jumps, jane_likes))\n\n# Rule 4: If an animal has legs, then it jumps\nsolver.add(Implies(animal_has_legs, animal_jumps))\n\n# Rule 5: If an animal is terricolous, then it has legs\nsolver.add(Implies(animal_terricolous, animal_has_legs))\n\n# Rule 6: If KiKi neither jumps nor has legs, then KiKi is terricolous or has legs\nsolver.add(Implies(And(Not(kiki), Not(animal_jumps), Not(animal_has_legs)), Or(animal_terricolous, animal_has_legs)))\n\n# Create assertions to check the query\nsolver.add(kiki)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(animal_terricolous))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(animal_terricolous)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - KiKi is terricolous\nelse:\n    print(\"B\")  # False - KiKi is not terricolous",
      "context": "If an animal barks, then Jane does not like it. All dogs are animals that bark. If an animal jumps, then Jane likes it. If an animal has legs, then it jumps. If an animal is terricolous, then it has legs. If KiKi neither jumps nor has legs, then KiKi is terricolous or has legs.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? KiKi is terricolous.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_26",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nbeijing_is_capital = Bool(\"beijing_is_capital\")\nbeijing_is_populous = Bool(\"beijing_is_populous\")\nbeijing_is_northern = Bool(\"beijing_is_northern\")\nbeijing_hosted_2008_olympics = Bool(\"beijing_hosted_2008_olympics\")\nbeijing_hosted_both_olympics = Bool(\"beijing_hosted_both_olympics\")\nbeijing_universities_rank_high = Bool(\"beijing_universities_rank_high\")\nbeijing_second_largest_city = Bool(\"beijing_second_largest_city\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Beijing is the capital of the People's Republic of China\nsolver.add(beijing_is_capital)\n\n# Rule 2: Beijing is the world's most populous national capital city\nsolver.add(beijing_is_populous)\n\n# Rule 3: Beijing is located in Northern China\nsolver.add(beijing_is_northern)\n\n# Rule 4: Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games\nsolver.add(beijing_hosted_2008_olympics)\n\n# Rule 5: Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics\nsolver.add(beijing_hosted_both_olympics)\n\n# Rule 6: Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world\nsolver.add(beijing_universities_rank_high)\n\n# Create assertions to check the query\n# Rule 7: Beijing is the second largest Chinese city by urban population (Possibility, not a strict constraint)\n# No direct constraint provided in the context, so we do not add any constraint for this statement\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Beijing NOT be the second largest Chinese city by urban population?\nsolver.push()\nsolver.add(Not(beijing_second_largest_city))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Beijing be the second largest Chinese city by urban population?\nsolver.push()\nsolver.add(beijing_second_largest_city)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both possibilities exist\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Beijing can be the second largest city by urban population\nelse:\n    print(\"B\")  # False - Beijing cannot be the second largest city by urban population",
      "context": "Beijing is the capital of the People's Republic of China. Beijing is the world's most populous national capital city. Beijing is located in Northern China. Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games. Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Beijing is the second largest Chinese city by urban population.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_33",
      "predicted": "C",
      "correct": "A",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nroderick_strong_leads = Bool(\"roderick_strong_leads\")\ndiamond_mine = Bool(\"diamond_mine\")\ncreed_brothers = Bool(\"creed_brothers\")\nivy_nile = Bool(\"ivy_nile\")\nimperium = Bool(\"imperium\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Roderick Strong leads Diamond Mine\nsolver.add(Implies(roderick_strong_leads, diamond_mine))\n\n# Rule 2: Diamond Mine includes the Creed Brothers and Ivy Nile\nsolver.add(And(diamond_mine, creed_brothers, ivy_nile))\n\n# Rule 3: Imperium has a feud with Diamond Mine\nsolver.add(Implies(imperium, Not(diamond_mine)))\n\n# Create assertions to check the query\n# Check if the query statement \"Roderick Strong leads a professional wrestling stable\" must be true\nsolver.push()\nsolver.add(Not(roderick_strong_leads))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(roderick_strong_leads)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Roderick Strong leads a professional wrestling stable\nelse:\n    print(\"B\")  # False - Roderick Strong does not lead a professional wrestling stable",
      "context": "Diamond Mine is a professional wrestling stable, formed in WWE. Roderick Strong leads Diamond Mine. Diamond Mine includes the Creed Brothers, and Ivy Nile. Imperium has a feud with Diamond Mine.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Roderick strong leads a professional wrestling stable.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_152",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nnew_vessel_press = Bool(\"new_vessel_press\")\nenglish_language = Bool(\"english_language\")\nneapolitan_chronicles = Bool(\"neapolitan_chronicles\")\nitalian_language = Bool(\"italian_language\")\npalace_of_flies = Bool(\"palace_of_flies\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All of New Vessel Press's published books are in English\nsolver.add(Implies(new_vessel_press, english_language))\n\n# Rule 2: Neapolitan Chronicles is a book published by New Vessel Press\nsolver.add(neapolitan_chronicles == new_vessel_press)\n\n# Rule 3: Neapolitan Chronicles was translated from Italian\nsolver.add(Implies(neapolitan_chronicles, italian_language))\n\n# Rule 4: Palace of Flies is a book published by New Vessel Press\nsolver.add(palace_of_flies == new_vessel_press)\n\n# Create assertions to check the query\n# Check if Palace of Flies was translated from Italian\nsolver.push()\nsolver.add(Not(Implies(palace_of_flies, italian_language)))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Check if Palace of Flies was not translated from Italian\nsolver.push()\nsolver.add(Implies(palace_of_flies, italian_language))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Palace of Flies was translated from Italian\nelse:\n    print(\"B\")  # False - Palace of Flies was not translated from Italian",
      "context": "New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Palace of Flies was translated from Italian.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_76",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nwork_student_jobs = Bool(\"work_student_jobs\")\nearn_money = Bool(\"earn_money\")\norder_takeout = Bool(\"order_takeout\")\nenjoy_dining = Bool(\"enjoy_dining\")\nnot_picky = Bool(\"not_picky\")\nspend_time_eating = Bool(\"spend_time_eating\")\nmary = Bool(\"mary\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If people work in student jobs on campus, then they need to earn money to help pay for their college tuition\nsolver.add(Implies(work_student_jobs, earn_money))\n\n# Rule 2: If people order takeout frequently in college, then they work in student jobs on campus\nsolver.add(Implies(order_takeout, work_student_jobs))\n\n# Rule 3: People either order takeout frequently in college or enjoy the dining hall meals and recipes\nsolver.add(Or(order_takeout, enjoy_dining))\n\n# Rule 4: If people enjoy the dining hall meals and recipes, then they are not picky eaters\nsolver.add(Implies(enjoy_dining, Not(not_picky)))\n\n# Rule 5: If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls\nsolver.add(Implies(enjoy_dining, spend_time_eating))\n\n# Rule 6: If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition\nsolver.add(Implies(And(mary, work_student_jobs, earn_money), And(Not(not_picky), Not(earn_money))))\n\n# Create assertions to check the query\n# Check if Mary needs to earn money to help pay for her college tuition\nsolver.add(earn_money)\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Mary NOT need to earn money to help pay for her college tuition?\nsolver.push()\nsolver.add(Not(earn_money))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Mary need to earn money to help pay for her college tuition?\nsolver.push()\nsolver.add(earn_money)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Mary needs to earn money\nelse:\n    print(\"B\")  # False - Mary does not need to earn money",
      "context": "If people work in student jobs on campus, then they need to earn money to help pay for their college tuition. If people order takeout frequently in college, then they work in student jobs on campus. People either order takeout frequently in college or enjoy the dining hall meals and recipes. If people enjoy the dining hall meals and recipes, then they are not picky eaters. If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls. If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Mary needs to earn money to help pay for her college tuition.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_23",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nnetflix_show = Bool(\"netflix_show\")\npopular_show = Bool(\"popular_show\")\nkaren_binge_watch = Bool(\"karen_binge_watch\")\nkaren_download = Bool(\"karen_download\")\nblack_mirror = Bool(\"black_mirror\")\nshare_to_lisa = Bool(\"share_to_lisa\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: \"Stranger Things\" is a popular Netflix show\nsolver.add(Implies(netflix_show, popular_show))\nsolver.add(netflix_show)\n\n# Rule 2: If a Netflix show is popular, Karen will binge-watch it\nsolver.add(Implies(popular_show, karen_binge_watch))\n\n# Rule 3: If and only if Karen binge-watches a Netflix show, she will download it\nsolver.add(Implies(karen_binge_watch, karen_download))\nsolver.add(Implies(karen_download, karen_binge_watch))\n\n# Rule 4: Karen does not download \"Black Mirror\"\nsolver.add(Not(black_mirror))\n\n# Rule 5: \"Black Mirror\" is a Netflix show\nsolver.add(Implies(black_mirror, netflix_show))\n\n# Rule 6: If Karen binge-watches a Netflix show, she will share it to Lisa\nsolver.add(Implies(karen_binge_watch, share_to_lisa))\n\n# Create assertions to check the query\n# Check if Karen will share \"Black Mirror\" to Lisa\nsolver.add(Implies(black_mirror, share_to_lisa))\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(share_to_lisa))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(share_to_lisa)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Karen will share \"Black Mirror\" to Lisa\nelse:\n    print(\"B\")  # False - Karen will not share \"Black Mirror\" to Lisa",
      "context": "\"Stranger Things\" is a popular Netflix show. If a Netflix show is popular, Karen will binge-watch it. If and only if Karen binge-watches a Netflix show, she will download it. Karen does not download \"Black Mirror\". \"Black Mirror\" is a Netflix show. If Karen binge-watches a Netflix show, she will share it to Lisa.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Karen will share \"Black Mirror\" to Lisa.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_11",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\neastern_wild_turkey = Bool(\"eastern_wild_turkey\")\nosceola_wild_turkey = Bool(\"osceola_wild_turkey\")\ngoulds_wild_turkey = Bool(\"goulds_wild_turkey\")\nmerriams_wild_turkey = Bool(\"merriams_wild_turkey\")\nrio_grande_wild_turkey = Bool(\"rio_grande_wild_turkey\")\nocellated_wild_turkey = Bool(\"ocellated_wild_turkey\")\ntom = Bool(\"tom\")\njoey = Bool(\"joey\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Tom is a wild turkey\nsolver.add(tom)\n\n# Rule 2: Tom is not an Eastern wild turkey\nsolver.add(Not(eastern_wild_turkey))\n\n# Rule 3: Tom is not an Osceola wild turkey\nsolver.add(Not(osceola_wild_turkey))\n\n# Rule 4: Tom is not a Gould's wild turkey\nsolver.add(Not(goulds_wild_turkey))\n\n# Rule 5: Tom is not a Merriam's wild turkey\nsolver.add(Not(merriams_wild_turkey))\n\n# Rule 6: Tom is not a Rio Grande wild turkey\nsolver.add(Not(rio_grande_wild_turkey))\n\n# Rule 7: Tom is not an Ocellated wild turkey\nsolver.add(Not(ocellated_wild_turkey))\n\n# Create assertions to check the query\n# Rule 8: Joey is a wild turkey\nsolver.add(joey)\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(joey))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(joey)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Joey is a wild turkey\nelse:\n    print(\"B\")  # False - Joey is not a wild turkey",
      "context": "There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild turkey, Rio Grande wild turkey, and Ocellated wild turkey. Tom is not an Eastern wild turkey. Tom is not an Osceola wild turkey. Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey. Tom is a wild turkey.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Joey is a wild turkey.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_150",
      "predicted": "C",
      "correct": "A",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nnew_vessel_press = Bool(\"new_vessel_press\")\nenglish_book = Bool(\"english_book\")\nneapolitan_chronicles = Bool(\"neapolitan_chronicles\")\nitalian_book = Bool(\"italian_book\")\npalace_of_flies = Bool(\"palace_of_flies\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All of New Vessel Press's published books are in English\nsolver.add(Implies(new_vessel_press, english_book))\n\n# Rule 2: Neapolitan Chronicles is a book published by New Vessel Press\nsolver.add(Implies(neapolitan_chronicles, new_vessel_press))\n\n# Rule 3: Neapolitan Chronicles was translated from Italian\nsolver.add(Implies(neapolitan_chronicles, italian_book))\n\n# Rule 4: Palace of Flies is a book published by New Vessel Press\nsolver.add(Implies(palace_of_flies, new_vessel_press))\n\n# Create assertions to check the query\n# Check if Neapolitan Chronicles is an English book\nsolver.add(Implies(neapolitan_chronicles, english_book))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Neapolitan Chronicles NOT be an English book?\nsolver.push()\nsolver.add(Not(english_book))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Neapolitan Chronicles be an English book?\nsolver.push()\nsolver.add(english_book)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be an English book\nelse:\n    print(\"B\")  # False - cannot be an English book",
      "context": "New Vessel Press is a publishing house which specializes in translating foreign literature into English. All of New Vessel Press's published books are in English. Neapolitan Chronicles is a book published by New Vessel Press. Neapolitan Chronicles was translated from Italian. Palace of Flies is a book published by New Vessel Press.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Neapolitan Chronicles is an English book.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_170",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ndeadly_disease = Bool(\"deadly_disease\")\nlow_survival_rate = Bool(\"low_survival_rate\")\nsevere_cancer = Bool(\"severe_cancer\")\nbile_duct_cancer = Bool(\"bile_duct_cancer\")\ncholangiocarcinoma = Bool(\"cholangiocarcinoma\")\nmild_flu = Bool(\"mild_flu\")\ncolorectal_cancer = Bool(\"colorectal_cancer\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If something is a deadly disease, then its survival rate is low\nsolver.add(Implies(deadly_disease, low_survival_rate))\n\n# Rule 2: All severe cancers are deadly diseases\nsolver.add(Implies(severe_cancer, deadly_disease))\n\n# Rule 3: Bile duct cancer is a severe cancer\nsolver.add(Implies(bile_duct_cancer, severe_cancer))\n\n# Rule 4: All Cholangiocarcinoma is bile duct cancer\nsolver.add(Implies(cholangiocarcinoma, bile_duct_cancer))\n\n# Rule 5: No one with mild flu has a low survival rate\nsolver.add(Implies(mild_flu, Not(low_survival_rate)))\n\n# Rule 6: If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer\nsolver.add(Implies(And(colorectal_cancer, low_survival_rate), Not(colorectal_cancer)))\n\n# Create assertions to check the query\nsolver.add(severe_cancer == True)  # Query statement: Colorectal cancer is a severe cancer\n\n# Determine if the statement is True, False, or Uncertain\nsolver.push()\nsolver.add(Not(severe_cancer))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nsolver.push()\nsolver.add(severe_cancer)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be a severe cancer\nelse:\n    print(\"B\")  # False - cannot be a severe cancer",
      "context": "If something is a deadly disease, then its survival rate is low. All severe cancers are deadly diseases. Bile duct cancer is a severe cancer. All Cholangiocarcinoma is bile duct cancer. No one with mild flu has a low survival rate. If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Colorectal cancer is a severe cancer",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_77",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nwork_in_student_jobs = Bool(\"work_in_student_jobs\")\nearn_money = Bool(\"earn_money\")\norder_takeout = Bool(\"order_takeout\")\nenjoy_dining_hall = Bool(\"enjoy_dining_hall\")\nnot_picky_eater = Bool(\"not_picky_eater\")\nspend_lot_of_time = Bool(\"spend_lot_of_time\")\nmary = Bool(\"mary\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If people work in student jobs on campus, then they need to earn money to help pay for their college tuition\nsolver.add(Implies(work_in_student_jobs, earn_money))\n\n# Rule 2: If people order takeout frequently in college, then they work in student jobs on campus\nsolver.add(Implies(order_takeout, work_in_student_jobs))\n\n# Rule 3: People either order takeout frequently in college or enjoy the dining hall meals and recipes\nsolver.add(Or(order_takeout, enjoy_dining_hall))\n\n# Rule 4: If people enjoy the dining hall meals and recipes, then they are not picky eaters\nsolver.add(Implies(enjoy_dining_hall, not_picky_eater))\n\n# Rule 5: If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls\nsolver.add(Implies(enjoy_dining_hall, spend_lot_of_time))\n\n# Rule 6: If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition\nsolver.add(Implies(And(mary, work_in_student_jobs, earn_money), And(not_picky_eater, Not(earn_money))))\n\n# Create assertions to check the query\n# Check if Mary is not a picky eater and spends a lot of her time eating and catching up with friends in the campus dining halls\nsolver.add(And(not_picky_eater, spend_lot_of_time))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Mary NOT be a picky eater and spend a lot of her time eating and catching up with friends in the campus dining halls?\nsolver.push()\nsolver.add(Not(And(not_picky_eater, spend_lot_of_time)))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Mary be a picky eater and spend a lot of her time eating and catching up with friends in the campus dining halls?\nsolver.push()\nsolver.add(And(not_picky_eater, spend_lot_of_time))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Mary is not a picky eater and spends a lot of her time eating and catching up with friends in the campus dining halls\nelse:\n    print(\"B\")  # False - Mary cannot be both a picky eater and spend a lot of her time eating and catching up with friends in the campus dining halls",
      "context": "If people work in student jobs on campus, then they need to earn money to help pay for their college tuition. If people order takeout frequently in college, then they work in student jobs on campus. People either order takeout frequently in college or enjoy the dining hall meals and recipes. If people enjoy the dining hall meals and recipes, then they are not picky eaters. If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls. If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Mary is not a picky eater and spends a lot of her time eating and catching up with friends in the campus dining halls.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_31",
      "predicted": "B",
      "correct": "A",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nperson = Bool(\"person\")\ngrand_slam_champion = Bool(\"grand_slam_champion\")\noscar_nominated_actor = Bool(\"oscar_nominated_actor\")\nprofessional_tennis_player = Bool(\"professional_tennis_player\")\ncelebrity = Bool(\"celebrity\")\nathlete = Bool(\"athlete\")\nwell_paid = Bool(\"well_paid\")\nfamous = Bool(\"famous\")\nlive_in_tax_haven = Bool(\"live_in_tax_haven\")\ndjokovic = Bool(\"djokovic\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: A person is either a Grand Slam champion or an Oscar-nominated actor\nsolver.add(Or(grand_slam_champion, oscar_nominated_actor) == person)\n\n# Rule 2: All people who are Grand Slam champions are professional tennis players\nsolver.add(Implies(grand_slam_champion, professional_tennis_player))\n\n# Rule 3: All Oscar-nominated actors are celebrities\nsolver.add(Implies(oscar_nominated_actor, celebrity))\n\n# Rule 4: All professional tennis players are athletes\nsolver.add(Implies(professional_tennis_player, athlete))\n\n# Rule 5: If a person is a celebrity then they are well paid\nsolver.add(Implies(celebrity, well_paid))\n\n# Rule 6: If a person is an athlete then they are famous\nsolver.add(Implies(athlete, famous))\n\n# Rule 7: All well-paid people live in tax havens\nsolver.add(Implies(well_paid, live_in_tax_haven))\n\n# Rule 8: If Djokovic is famous and is an athlete, then Djokovic lives in well paid\nsolver.add(Implies(And(djokovic, famous, athlete), well_paid))\n\n# Create assertions to check the query\n# Check if Djokovic lives in a tax haven\nsolver.add(Not(live_in_tax_haven))\n\n# Determine if the statement is True, False, or Uncertain\nif solver.check() == sat:\n    print(\"B\")  # False - Djokovic does not live in a tax haven\nelse:\n    print(\"A\")  # True - Djokovic lives in a tax haven",
      "context": "A person is either a Grand Slam champion or an Oscar-nominated actor. All people who are Grand Slam champions are professional tennis players. All Oscar-nominated actors are celebrities. All professional tennis players are athletes. If a person is a celebrity then they are well paid. If a person is an athlete then they are famous. All well-paid people live in tax havens. If Djokovic is famous and is an athlete, then Djokovic lives in well paid.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Djokovic lives in a tax haven.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_14",
      "predicted": "C",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nlegend_of_zelda = Bool(\"legend_of_zelda\")\njapanese_game_company = Bool(\"japanese_game_company\")\ntop_10_list = Bool(\"top_10_list\")\nmore_than_one_million_copies = Bool(\"more_than_one_million_copies\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: A Japanese game company created the game the Legend of Zelda\nsolver.add(Implies(legend_of_zelda, japanese_game_company))\n\n# Rule 2: All games in the Top 10 list are made by Japanese game companies\nsolver.add(Implies(top_10_list, japanese_game_company))\n\n# Rule 3: If a game sells more than one million copies, then it will be selected into the Top 10 list\nsolver.add(Implies(more_than_one_million_copies, top_10_list))\n\n# Rule 4: The Legend of Zelda sold more than one million copies (fact)\nsolver.add(more_than_one_million_copies)\n\n# Create assertions to check the query\n# Check if the Legend of Zelda is not in the Top 10 list\nsolver.add(Not(top_10_list))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can the Legend of Zelda be in the Top 10 list?\nsolver.push()\nsolver.add(top_10_list)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can the Legend of Zelda NOT be in the Top 10 list?\nsolver.push()\nsolver.add(Not(top_10_list))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and not can_be_false:\n    print(\"B\")  # False - Legend of Zelda is in the Top 10 list\nelif not can_be_true and can_be_false:\n    print(\"A\")  # True - Legend of Zelda is not in the Top 10 list\nelse:\n    print(\"C\")  # Uncertain",
      "context": "A Japanese game company created the game the Legend of Zelda. All games in the Top 10 list are made by Japanese game companies. [BG] If a game sells more than one million copies, then it will be selected into the Top 10 list. The Legend of Zelda sold more than one million copies.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? The Legend of Zelda is not in the Top 10 list.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_129",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nhas_wedding = Bool(\"has_wedding\")\nhas_child = Bool(\"has_child\")\ntravel_paris_honeymoon = Bool(\"travel_paris_honeymoon\")\nwedding_in_july = Bool(\"wedding_in_july\")\nwell_attended = Bool(\"well_attended\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All people who have a wedding are people who have at least one child\nsolver.add(Implies(has_wedding, has_child))\n\n# Rule 2: All people who travel to Paris for their honeymoon have a wedding\nsolver.add(Implies(travel_paris_honeymoon, has_wedding))\n\n# Rule 3: All weddings that occur in July belong to people who travel to Paris for their honeymoon\nsolver.add(Implies(wedding_in_july, travel_paris_honeymoon))\n\n# Rule 4: Some weddings in July are well-attended\n# We don't add a constraint for \"some\" - it just means well-attended and not well-attended are possible\n\n# Rule 5: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding\nsolver.add(Implies(has_child, And(Not(travel_paris_honeymoon), Not(has_wedding))))\n\n# Rule 6: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon\nsolver.add(Implies(well_attended, Or(wedding_in_july, And(Not(wedding_in_july), travel_paris_honeymoon))))\n\n# Create assertions to check the query\n# Rule 7: John does not have a wedding that is well-attended\nsolver.add(Not(well_attended))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can John have a wedding that is well-attended?\nsolver.push()\nsolver.add(well_attended)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can John NOT have a wedding that is well-attended?\nsolver.push()\nsolver.add(Not(well_attended))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"B\")  # False - cannot be well-attended\nelse:\n    print(\"A\")  # True - must not be well-attended",
      "context": "All people who have a wedding are people who have at least one child. All people who travel to Paris for their honeymoon are people who have a wedding. All weddings that occur in July belong to people who travel to Paris for their honeymoon. Some weddings in July are well-attended. If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding. If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? John does not have a wedding that is well-attended.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_40",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ntimeless = Bool(\"timeless\")\nmass_product = Bool(\"mass_product\")\nzaha_hadid = Bool(\"zaha_hadid\")\nkelly_wearstler = Bool(\"kelly_wearstler\")\nevocative = Bool(\"evocative\")\ndreamy = Bool(\"dreamy\")\nmax_design = Bool(\"max_design\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All of Zaha Hadid's design styles are timeless\nsolver.add(Implies(zaha_hadid, timeless))\n\n# Rule 2: No mass product design is timeless\nsolver.add(Implies(mass_product, Not(timeless)))\n\n# Rule 3: Either Zaha Hadid's design style or Kelly Wearstler's design style\nsolver.add(Or(zaha_hadid, kelly_wearstler))\n\n# Rule 4: All of Kelly Wearstler's design styles are evocative\nsolver.add(Implies(kelly_wearstler, evocative))\n\n# Rule 5: All of Kelly Wearstler's design styles are dreamy\nsolver.add(Implies(kelly_wearstler, dreamy))\n\n# Rule 6: If a design by Max is timeless, then a design by Max is a mass product design and evocative\nsolver.add(Implies(max_design, And(timeless, mass_product, evocative))\n\n# Create assertions to check the query\n# Query: A design by Max is evocative and dreamy\nsolver.add(And(evocative, dreamy))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can a design by Max NOT be evocative and dreamy?\nsolver.push()\nsolver.add(Not(And(evocative, dreamy)))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can a design by Max be evocative and dreamy?\nsolver.push()\nsolver.add(And(evocative, dreamy))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be evocative and dreamy\nelse:\n    print(\"B\")  # False - cannot be evocative and dreamy",
      "context": "All of Zaha Hadid's design styles are timeless. No mass product design is timeless. Either Zaha Hadid's design style or Kelly Wearstler's design style. All of Kelly Wearstler's design styles are evocative. All of Kelly Wearstler's design styles are dreamy. If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? A design by Max is evocative and dreamy.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_4",
      "predicted": "A",
      "correct": "C",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nemployee = Bool(\"employee\")\nschedule_meeting = Bool(\"schedule_meeting\")\nappear_in_company = Bool(\"appear_in_company\")\nhave_lunch_in_company = Bool(\"have_lunch_in_company\")\nhave_lunch_at_home = Bool(\"have_lunch_at_home\")\nwork_remotely = Bool(\"work_remotely\")\nin_other_countries = Bool(\"in_other_countries\")\nmanager = Bool(\"manager\")\njames = Bool(\"james\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All employees who schedule a meeting with their customers will appear in the company today\nsolver.add(Implies(And(employee, schedule_meeting), appear_in_company))\n\n# Rule 2: Everyone who has lunch in the company schedules meetings with their customers\nsolver.add(Implies(have_lunch_in_company, schedule_meeting))\n\n# Rule 3: Employees will either have lunch in the company or have lunch at home\nsolver.add(Or(have_lunch_in_company, have_lunch_at_home))\n\n# Rule 4: If an employee has lunch at home, then he/she is working remotely from home\nsolver.add(Implies(have_lunch_at_home, work_remotely))\n\n# Rule 5: All employees who are in other countries work remotely from home\nsolver.add(Implies(And(employee, in_other_countries), work_remotely))\n\n# Rule 6: No managers work remotely from home\nsolver.add(Implies(manager, Not(work_remotely)))\n\n# Rule 7: James is either a manager and appears in the company today or neither a manager nor appears in the company today\nsolver.add(Or(And(james, manager, appear_in_company), And(james, Not(manager), Not(appear_in_company)))\n\n# Create assertions to check the query\n# Query: James does not have lunch in the company\nsolver.add(Not(have_lunch_in_company))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can James have lunch in the company?\nsolver.push()\nsolver.add(have_lunch_in_company)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can James NOT have lunch in the company?\nsolver.push()\nsolver.add(Not(have_lunch_in_company))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and not can_be_false:\n    print(\"B\")  # False - James can have lunch in the company\nelif not can_be_true and can_be_false:\n    print(\"A\")  # True - James does not have lunch in the company\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "All employees who schedule a meeting with their customers will appear in the company today. Everyone who has lunch in the company schedules meetings with their customers. Employees will either have lunch in the company or have lunch at home. If an employee has lunch at home, then he/she is working remotely from home. All employees who are in other countries work remotely from home. No managers work remotely from home. James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? James does not have lunch in the company.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_132",
      "predicted": "C",
      "correct": "A",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nsome_mammals_have_teeth = Bool(\"some_mammals_have_teeth\")\nplatypus_have_no_teeth = Bool(\"platypus_have_no_teeth\")\nplatypus_are_mammals = Bool(\"platypus_are_mammals\")\nhumans_have_teeth = Bool(\"humans_have_teeth\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Some mammals have teeth\n# We don't add a constraint for \"some\" - it just means both having teeth and not having teeth are possible\n\n# Rule 2: Platypus have no teeth\nsolver.add(Not(platypus_have_no_teeth))\n\n# Rule 3: Platypus are mammals\nsolver.add(Implies(platypus_are_mammals, platypus_have_no_teeth))\n\n# Rule 4: Humans have teeth\nsolver.add(humans_have_teeth)\n\n# Create assertions to check the query\n# Check if the statement \"Platypus are mammals with no teeth\" must be true\nsolver.push()\nsolver.add(platypus_are_mammals)\nsolver.add(Not(platypus_have_no_teeth))\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Check if the statement \"Platypus are mammals with no teeth\" must be false\nsolver.push()\nsolver.add(Not(platypus_are_mammals))\nsolver.add(Not(Not(platypus_have_no_teeth)))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine if the statement is True, False, or Uncertain\nif can_be_true and not can_be_false:\n    print(\"A\")  # True - Platypus are mammals with no teeth\nelif not can_be_true and can_be_false:\n    print(\"B\")  # False - Platypus are not mammals with no teeth\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "[BG] Some mammals have teeth. Platypus have no teeth. Platypus are mammals. Humans have teeth.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Platypus are mammals with no teeth.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_176",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nsporting_event = Bool(\"sporting_event\")\nolympic_games = Bool(\"olympic_games\")\nlast_olympic_games = Bool(\"last_olympic_games\")\ntokyo = Bool(\"tokyo\")\nunited_states = Bool(\"united_states\")\nworld_championships = Bool(\"world_championships\")\nmost_medals = Bool(\"most_medals\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: The Olympic games is a sporting event\nsolver.add(Implies(olympic_games, sporting_event))\n\n# Rule 2: The last Olympic games was in Tokyo\nsolver.add(Implies(last_olympic_games, tokyo))\n\n# Rule 3: The United States won the most medals in Tokyo\nsolver.add(Implies(tokyo, Implies(united_states, most_medals)))\n\n# Create assertions to check the query\n# We do not have any direct information about the World Championships\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can the World Championships NOT be a sporting event?\nsolver.push()\nsolver.add(Not(sporting_event))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can the World Championships be a sporting event?\nsolver.push()\nsolver.add(sporting_event)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - must be a sporting event\nelse:\n    print(\"B\")  # False - cannot be a sporting event",
      "context": "[BG] The Olympic games is a sporting event. The last Olympic games was in Tokyo. The United States won the most medals in Tokyo.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? The world championships is a sporting event.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_53",
      "predicted": "C",
      "correct": "C",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ngerman_is_romance = Bool(\"german_is_romance\")\nfrench_is_romance = Bool(\"french_is_romance\")\nspanish_is_romance = Bool(\"spanish_is_romance\")\ngerman_related_to_spanish = Bool(\"german_related_to_spanish\")\nbasque_is_related = Bool(\"basque_is_related\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: All Romance languages are Indo-European languages\nsolver.add(Implies(french_is_romance, french_is_romance))\nsolver.add(Implies(spanish_is_romance, spanish_is_romance))\n\n# Rule 2: The Romance languages are a language family\nsolver.add(Implies(french_is_romance, french_is_romance))\nsolver.add(Implies(spanish_is_romance, spanish_is_romance))\n\n# Rule 3: All languages within a language family are related to each other\nsolver.add(Implies(french_is_romance, french_is_romance))\nsolver.add(Implies(spanish_is_romance, spanish_is_romance))\n\n# Rule 4: French and Spanish are both Romance languages\nsolver.add(And(french_is_romance, spanish_is_romance))\n\n# Rule 5: German is related to Spanish\nsolver.add(Implies(german_related_to_spanish, german_related_to_spanish))\n\n# Rule 6: Basque is not related to any other language\nsolver.add(Not(basque_is_related))\n\n# Create assertions to check the query\n# Rule 7: German is a Romance language\nsolver.add(Implies(german_is_romance, german_is_romance))\n\n# Rule 8: German is related to Spanish\nsolver.add(Implies(german_is_romance, german_related_to_spanish))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can German NOT be a Romance language?\nsolver.push()\nsolver.add(Not(german_is_romance))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can German be a Romance language?\nsolver.push()\nsolver.add(german_is_romance)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - German is a Romance language\nelse:\n    print(\"B\")  # False - German is not a Romance language",
      "context": "All Romance languages are Indo-European languages. The Romance languages are a language family. All languages within a language family are related to each other. French and Spanish are both Romance languages. German is related to Spanish. Basque is not related to any other language.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? German is a Romance language.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_171",
      "predicted": "B",
      "correct": "A",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\ndeadly_disease = Bool(\"deadly_disease\")\nlow_survival_rate = Bool(\"low_survival_rate\")\nsevere_cancer = Bool(\"severe_cancer\")\nbile_duct_cancer = Bool(\"bile_duct_cancer\")\ncholangiocarcinoma = Bool(\"cholangiocarcinoma\")\nmild_flu = Bool(\"mild_flu\")\ncolorectal_cancer = Bool(\"colorectal_cancer\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: If something is a deadly disease, then its survival rate is low\nsolver.add(Implies(deadly_disease, low_survival_rate))\n\n# Rule 2: All severe cancers are deadly diseases\nsolver.add(Implies(severe_cancer, deadly_disease))\n\n# Rule 3: Bile duct cancer is a severe cancer\nsolver.add(Implies(bile_duct_cancer, severe_cancer))\n\n# Rule 4: All Cholangiocarcinoma is bile duct cancer\nsolver.add(Implies(cholangiocarcinoma, bile_duct_cancer))\n\n# Rule 5: No one with mild flu has a low survival rate\nsolver.add(Implies(mild_flu, Not(low_survival_rate)))\n\n# Rule 6: If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer\nsolver.add(Implies(And(colorectal_cancer, low_survival_rate), Not(colorectal_cancer)))\n\n# Create assertions to check the query\n# Query: If colorectal cancer is a bile duct cancer or a Cholangiocarcinoma, then colorectal cancer is a bile duct cancer and a mild flu\nquery = Implies(Or(colorectal_cancer, cholangiocarcinoma), And(colorectal_cancer, mild_flu))\n\n# Check if the statement is True, False, or Uncertain\nsolver.add(Not(query))  # Check if the query must be False\nif solver.check() == unsat:\n    print(\"A\")  # True - the statement must be True\nelse:\n    solver.add(query)  # Check if the query must be True\n    if solver.check() == unsat:\n        print(\"B\")  # False - the statement must be False\n    else:\n        print(\"C\")  # Uncertain - the statement can be either True or False",
      "context": "If something is a deadly disease, then its survival rate is low. All severe cancers are deadly diseases. Bile duct cancer is a severe cancer. All Cholangiocarcinoma is bile duct cancer. No one with mild flu has a low survival rate. If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? If colorectal cancer is a bile duct cancer or a Cholangiocarcinoma, then colorectal cancer is a bile duct cancer and a mild flu.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_21",
      "predicted": "A",
      "correct": "A",
      "is_correct": true,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nnetflix_show = Bool(\"netflix_show\")\npopular_show = Bool(\"popular_show\")\nkaren_binge_watch = Bool(\"karen_binge_watch\")\nkaren_download = Bool(\"karen_download\")\nblack_mirror = Bool(\"black_mirror\")\nstranger_things = Bool(\"stranger_things\")\nshare_to_lisa = Bool(\"share_to_lisa\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: \"Stranger Things\" is a popular Netflix show\nsolver.add(Implies(stranger_things, popular_show))\n\n# Rule 2: If a Netflix show is popular, Karen will binge-watch it\nsolver.add(Implies(popular_show, karen_binge_watch))\n\n# Rule 3: If and only if Karen binge-watches a Netflix show, she will download it\nsolver.add(Implies(karen_binge_watch, karen_download))\nsolver.add(Implies(karen_download, karen_binge_watch))\n\n# Rule 4: Karen does not download \"Black Mirror\"\nsolver.add(Not(black_mirror))\n\n# Rule 5: \"Black Mirror\" is a Netflix show\nsolver.add(Implies(black_mirror, netflix_show))\n\n# Rule 6: If Karen binge-watches a Netflix show, she will share it to Lisa\nsolver.add(Implies(karen_binge_watch, share_to_lisa))\n\n# Create assertions to check the query\nsolver.add(stranger_things)  # Karen will share \"Stranger Things\" to Lisa\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can Karen NOT share \"Stranger Things\" to Lisa?\nsolver.push()\nsolver.add(Not(share_to_lisa))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can Karen share \"Stranger Things\" to Lisa?\nsolver.push()\nsolver.add(share_to_lisa)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and can_be_false:\n    print(\"C\")  # Uncertain - both are possible\nelif can_be_true and not can_be_false:\n    print(\"A\")  # True - Karen will share \"Stranger Things\" to Lisa\nelse:\n    print(\"B\")  # False - Karen will not share \"Stranger Things\" to Lisa",
      "context": "\"Stranger Things\" is a popular Netflix show. If a Netflix show is popular, Karen will binge-watch it. If and only if Karen binge-watches a Netflix show, she will download it. Karen does not download \"Black Mirror\". \"Black Mirror\" is a Netflix show. If Karen binge-watches a Netflix show, she will share it to Lisa.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? Karen will share \"Stranger Things\" to Lisa.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    },
    {
      "id": "FOLIO_dev_169",
      "predicted": "A",
      "correct": "B",
      "is_correct": false,
      "pseudocode": null,
      "mode": "direct",
      "error": null,
      "attempts": 1,
      "code": "from z3 import *\n\n# Define boolean variables for all predicates and entities\nheinrich_schmidt = Bool(\"heinrich_schmidt\")\nnazi_german_politician = Bool(\"nazi_german_politician\")\nprussian_state_parliament_member = Bool(\"prussian_state_parliament_member\")\nnazi_reichstag_member = Bool(\"nazi_reichstag_member\")\n\n# Create a solver instance\nsolver = Solver()\n\n# Encode all logical rules from the context\n# Rule 1: Heinrich Schmidt was a Nazi German politician\nsolver.add(Implies(heinrich_schmidt, nazi_german_politician))\n\n# Rule 2: Heinrich Schmidt was a member of the Prussian State Parliament\nsolver.add(Implies(heinrich_schmidt, prussian_state_parliament_member))\n\n# Rule 3: Heinrich Schmidt was a member of the Nazi Reichstag\nsolver.add(Implies(heinrich_schmidt, nazi_reichstag_member))\n\n# Create assertions to check the query\n# Query: No politicians are part of the Nazi Reichstag\nsolver.add(Not(nazi_german_politician) or Not(nazi_reichstag_member))\n\n# Determine if the statement is True, False, or Uncertain\n# Test 1: Can politicians be part of the Nazi Reichstag?\nsolver.push()\nsolver.add(nazi_german_politician, nazi_reichstag_member)\ncan_be_true = (solver.check() == sat)\nsolver.pop()\n\n# Test 2: Can no politicians be part of the Nazi Reichstag?\nsolver.push()\nsolver.add(Not(nazi_german_politician) or Not(nazi_reichstag_member))\ncan_be_false = (solver.check() == sat)\nsolver.pop()\n\n# Determine the answer\nif can_be_true and not can_be_false:\n    print(\"B\")  # False - politicians can be part of the Nazi Reichstag\nelif not can_be_true and can_be_false:\n    print(\"A\")  # True - no politicians are part of the Nazi Reichstag\nelse:\n    print(\"C\")  # Uncertain - both possibilities exist",
      "context": "Heinrich Scmidt was a Nazi German politician. Heeinrich Scmidt was also a member of the Prussian State Parliament and the Nazi Reichstag.",
      "question": "Based on the above information, is the following statement true, false, or uncertain? No politicans are part of the Nazi Reichstag.",
      "options": [
        "A) True",
        "B) False",
        "C) Uncertain"
      ]
    }
  ]
}